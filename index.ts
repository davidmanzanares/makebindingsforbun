#!/usr/bin/env bun
import fs from "fs/promises";
import { spawnSync } from "bun";
import { resolve } from "path";

type IntegerType = {
  class: "integer";
  bytes: number;
  bunType: string;
};
type FloatType = {
  class: "float";
  bytes: number;
  bunType: string;
};
type StructType = {
  class: "struct";
  structName: string;
  bytes: number;
  properties: StructProperty[];
};
type StructProperty = {
  propertyName: string;
  type: Type;
  byteIndex: number;
};
type EnumType = {
  class: "enum";
  name: string;
  values: { [key: string]: EnumValue };
  bytes: 4;
  bunType: "FFIType.u32";
};
type EnumValue = {
  name: string;
  value: number;
};
type PtrType = {
  class: "ptr";
  bytes: 8;
  to?: Type;
  bunType: "FFIType.ptr";
};
type AliasType = {
  class: "alias";
  alias: string;
  to: Type;
};

type OpaqueStructType = {
  class: "opaqueStruct";
  name: string;
};

// Fixed-size array, incomplete support
type Array1D = {
  class: "array";
  size: number;
  to: Type;
  bytes: number;
};

// N-dimensional array Type, incomplete support
type ArrayND = {
  class: "arrayND";
};

type NonAliasTypes =
  | IntegerType
  | FloatType
  | StructType
  | EnumType
  | PtrType
  | OpaqueStructType
  | Array1D
  | ArrayND;

type Type = NonAliasTypes | AliasType;

type MacroConstant = {
  name: string;
  value: string | number;
};

const Uint8 = {
  class: "integer",
  bytes: 1,
  bunType: "FFIType.u8",
} as IntegerType;
const Uint16 = {
  class: "integer",
  bytes: 2,
  bunType: "FFIType.u16",
} as IntegerType;
const Uint32 = {
  class: "integer",
  bytes: 4,
  bunType: "FFIType.u32",
} as IntegerType;
const Uint64 = {
  class: "integer",
  bytes: 8,
  bunType: "FFIType.u64",
} as IntegerType;

const Int8 = {
  class: "integer",
  bytes: 1,
  bunType: "FFIType.i8",
} as IntegerType;
const Int16 = {
  class: "integer",
  bytes: 2,
  bunType: "FFIType.i16",
} as IntegerType;
const Int32 = {
  class: "integer",
  bytes: 4,
  bunType: "FFIType.i32",
} as IntegerType;
const Int64 = {
  class: "integer",
  bytes: 8,
  bunType: "FFIType.i64",
} as IntegerType;

const Float32 = {
  class: "float",
  bytes: 4,
  bunType: "FFIType.f32",
} as FloatType;
const Float64 = {
  class: "float",
  bytes: 8,
  bunType: "FFIType.f64",
} as FloatType;

type Symbol = {
  name: string;
  args: SymbolArg[];
  returnType: Type;
};

type SymbolArg = {
  name: string;
  type: Type;
};

type TypeMap = { [key: string]: Type };

type MacroConstantMap = { [key: string]: MacroConstant };

type SymbolMap = { [key: string]: Symbol };

async function main() {
  try {
    const skipHeaderParsing = process.argv.some(
      (arg) => arg === "--skip-header-parsing"
    );
    const configRaw = await fs.readFile(process.argv[2], "utf-8");
    const config = JSON.parse(configRaw);

    const ast = await getHeaderAST(config, skipHeaderParsing);

    const macroConstantMap = await getMacroDefinitions(config);
    const typeMap = getTypes(config, ast);
    const symbolMap = getSymbolMap(config, ast, typeMap);

    const constantsSection = Object.values(macroConstantMap)
      .map((constant) => `export const ${constant.name} = ${constant.value};`)
      .join("\n");

    const typeSection = Object.values(typeMap).map(getTypeUtils).join("");
    const functionSection = Object.values(symbolMap)
      .map((s) => getFunctionUtils(config, s))
      .join("");

    const dlopenStmt = `
import { dlopen, FFIType, ptr, read } from "bun:ffi";

globalThis.ptrBufferRefs = new Set();

${constantsSection}

${typeSection}

${functionSection}

`;

    await fs.writeFile(`autogenerated/${config.name}.ts`, dlopenStmt);
  } catch (error) {
    console.log(error);
  }
}

async function getHeaderAST(config: any, skipHeaderParsing: boolean) {
  let header_ast;
  if (!skipHeaderParsing) {
    console.log("Generating header AST", resolve(config.headerFile), __dirname);
    const result = spawnSync(
      [
        "python",
        "bunpycparser.py",
        resolve(config.headerFile),
        resolve(".") + `/autogenerated/${config.name}_header_ast.json`,
        config.preprocessorExtra || "",
      ],
      { cwd: __dirname, stdin: "inherit", stdout: "inherit" }
    );
    if (!result.success) {
      if (!result.stderr) {
        throw new Error("Error with no stderr when executing bunpycparser");
      }
      throw new Error(String.fromCharCode(...result.stderr));
    }
  }
  header_ast = await fs.readFile(
    `autogenerated/${config.name}_header_ast.json`,
    "utf-8"
  );
  const ast = JSON.parse(header_ast);
  console.log(
    "Loaded header AST",
    resolve(".") + `/autogenerated/${config.name}_header_ast.json`
  );
  return ast;
}
function getTypes(config: any, ast: any): TypeMap {
  const typeMap = {} as TypeMap;
  typeMap["uint8_t"] = Uint8;
  typeMap["uint16_t"] = Uint16;
  typeMap["uint32_t"] = Uint32;
  typeMap["uint64_t"] = Uint64;
  typeMap["int8_t"] = Int8;
  typeMap["int16_t"] = Int16;
  typeMap["int32_t"] = Int32;
  typeMap["int64_t"] = Int64;
  typeMap["int"] = Int32;
  typeMap["float"] = Float32;
  typeMap["double"] = Float64;
  ast.ext
    .filter(
      (node: any) =>
        node.coord.includes(config.filterBy || config.headerFile) &&
        node._nodetype === "Typedef" &&
        node.type._nodetype === "TypeDecl"
    )
    .forEach((node: any) => {
      const name = node.name as string;
      if (node.type.type._nodetype === "Enum") {
        const type = {
          name,
          class: "enum",
          values: {},
          bytes: 4,
          bunType: "FFIType.u32",
        } as EnumType;
        node.type.type.values.enumerators.forEach((enumValue: any) => {
          let value = Number(enumValue.value.value);
          if (enumValue.value.op === "-") {
            value = -Number(enumValue.value.expr.value);
          }
          const name = enumValue.name as string;
          type.values[name] = {
            name,
            value,
          } as EnumValue;
        });
        typeMap[name] = type;
      } else if (node.type.type._nodetype === "Struct") {
        if (node.type.type.decls === null) {
          typeMap[name] = {
            class: "opaqueStruct",
            name,
          };
          return;
        }
        const properties = node.type.type.decls.map(
          (structProp: any): StructProperty => {
            const propertyName = structProp.name;

            if (structProp.type._nodetype === "PtrDecl") {
              const name =
                structProp.type.type.type.name ||
                (structProp.type.type.type.names &&
                  structProp.type.type.type.names[0]);
              return {
                propertyName,
                type: {
                  class: "ptr",
                  to: typeMap[name],
                  bytes: 8,
                  bunType: "FFIType.ptr",
                },
                byteIndex: -1,
              };
            } else if (structProp.type._nodetype === "ArrayDecl") {
              if (structProp.type.type.dim) {
                // TODO
                return {
                  propertyName,
                  type: {
                    class: "arrayND",
                  },
                  byteIndex: -1,
                };
              }
              const subtype = structProp.type.type.type.names[0];
              const size = structProp.type.dim.value.replace("U", "");
              const to = typeMap[subtype] || {
                class: "ptr",
                to: "void",
                bytes: 8,
                bunType: "FFIType.ptr",
              };
              return {
                propertyName,
                type: {
                  class: "array",
                  size,
                  to,
                  bytes: typeResolveBytes(to),
                },
                byteIndex: -1,
              };
            } else {
              const alias = structProp.type.type.names[0];
              return {
                propertyName,
                type: {
                  class: "alias",
                  alias,
                  to: typeMap[alias] || {
                    class: "ptr",
                    to: "void",
                    bytes: 8,
                    bunType: "FFIType.ptr",
                  },
                },
                byteIndex: -1,
              };
            }
          }
        ) as StructProperty[];

        let bytes = 0;
        let structAligment = 0;
        properties.forEach((prop) => {
          let n = prop.type;
          while (n.class === "alias") {
            n = n.to;
          }
          if (!("bytes" in n)) {
            bytes = Number.NaN;
            return;
          }
          // Quick stub to take struct padding into account
          // this is highly likely plagued with bugs in some cases
          let alignmentBytes = Math.min(n.bytes, 16);
          if (n.class === "struct") {
            // Align to the most restrictive member of the struct
            alignmentBytes = Math.min(
              Math.max(...n.properties.map((p) => typeResolveBytes(p.type)))
            );
          }
          structAligment = Math.max(structAligment, alignmentBytes);
          const missaligment = bytes % alignmentBytes;
          if (missaligment) {
            const padding = alignmentBytes - missaligment;
            bytes += padding;
          }
          prop.byteIndex = bytes;
          bytes += n.bytes;
        });

        const missaligment = bytes % structAligment;
        if (missaligment) {
          const padding = structAligment - missaligment;
          bytes += padding;
        }

        const type = {
          class: "struct",
          structName: node.type.declname,
          properties,
          bytes,
          structAligment: structAligment,
        } as StructType;
        typeMap[name] = type;
      } else if (node.type.type._nodetype === "IdentifierType") {
        const alias = node.type.type.names[0] as string;
        typeMap[name] = {
          class: "alias",
          alias,
          to: typeMap[alias],
        };
      }
    });
  return typeMap;
}

function structToC(
  type: StructType,
  prefix: string,
  byteIndex: number,
  runtimeOffset: string = ""
): string {
  const propertyToC = type.properties
    .map((prop) => {
      const type = typeResolveAlias(prop.type);
      const access = `${prefix}.${prop.propertyName}`;
      const offset = byteIndex + prop.byteIndex;
      if (type.class === "ptr") {
        let to;
        // TODO avoid using BigInts, using a couple of setuint32 may be faster
        if (type.to && type.to.class === "struct") {
          return `\tif (${access}){
\t\tconst wrapped = ${type.to.structName}_to_C(${access}, false);
\t\trefList.push(wrapped.buffer);
\t\tview.setBigUint64(${offset}${runtimeOffset}, BigInt(wrapped.ptr||0), true);
\t}else{
\t\tview.setBigUint64(${offset}${runtimeOffset}, BigInt(${access}||0), true);
\t}`;
        } else {
          return `
\tview.setBigUint64(${offset}${runtimeOffset}, BigInt(${access}||0), true);
\tview.setBigUint64(${offset}${runtimeOffset}, BigInt(${access}||0), true);
`;
        }
      } else if (type.class === "integer" || type.class === "float") {
        switch (type.bunType) {
          case "FFIType.u8":
            return `\tview.setUint8(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.u16":
            return `\tview.setUint16(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.u32":
            return `\tview.setUint32(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.u64":
            return `\tview.setUint64(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.i8":
            return `\tview.setInt8(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.i16":
            return `\tview.setInt16(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.i32":
            return `\tview.setInt32(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.i64":
            return `\tview.setInt64(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.f32":
            return `\tview.setFloat32(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          case "FFIType.f64":
            return `\tview.setFloat64(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true);`;
          default:
            throw new Error("unimplemented");
        }
      } else if (type.class === "enum") {
        return `\tview.setUint32(${offset}${runtimeOffset}, ${prefix}.${prop.propertyName}, true)`;
      } else if (type.class === "struct") {
        const copyNested = structToC(type, `${access}`, offset, runtimeOffset);
        return `\tif (${access}){
${copyNested}
\t}`;
      } else {
      }
      return "";
    })
    .join("\n");
  return propertyToC;
}

function getTypeUtils(type: Type): string {
  if (type.class === "struct") {
    const propertyCopyFromC = type.properties
      .map((prop) => {
        const type = typeResolveAlias(prop.type);
        if (type.class === "ptr") {
          let to;
          if (!type.to) {
            to = `read.ptr(ptr)`;
          } else if (type.to.class === "struct") {
            to = `${type.to.structName}_from_C(read.ptr(ptr))`;
          }
          return `\t\t${prop.propertyName}: ${to}`;
        } else if (type.class === "integer") {
          if (type.bunType === "FFIType.u32") {
            return `\t\t${prop.propertyName}: read.u32(ptr, ${prop.byteIndex})`;
          }
        } else if (type.class === "enum") {
          return `\t\t${prop.propertyName}: read.u32(ptr, ${prop.byteIndex})`;
        }
        return `\t\t${prop.propertyName}: null`;
      })
      .join(",\n");

    const to_C = `
export function ${type.structName}_alloc_array(size){
\tconst buffer = new ArrayBuffer(${type.bytes}*size);
\treturn ptr(buffer);
}
export function ${type.structName}_to_C(obj, keepRef=true){
\tif (Array.isArray(obj)){
\tconst buffer = new ArrayBuffer(${type.bytes}*obj.length);
\tconst refList = [buffer];
\tif (keepRef){  globalThis.ptrBufferRefs.add(refList);}
\tconst view = new DataView(buffer);
\tobj.forEach((obj, i)=>{
${structToC(type, "obj", 0, `+(i*${type.bytes})`)}
\t});
\treturn {buffer, ptr: ptr(buffer), free: ()=>{globalThis.ptrBufferRefs.delete(refList)}};
}
\tconst buffer = new ArrayBuffer(${type.bytes});
\tconst refList = [buffer];
\tif (keepRef){  globalThis.ptrBufferRefs.add(refList);}
\tconst view = new DataView(buffer);
${structToC(type, "obj", 0)}
\treturn {buffer, ptr: ptr(buffer), free: ()=>{globalThis.ptrBufferRefs.delete(refList)}};
}
export function ${type.structName}_from_C(ptr){
\tconst obj = {
${propertyCopyFromC}
\t};
\treturn obj;
}

`;
    return to_C;
  } else if (type.class === "enum") {
    const values = Object.values(type.values).map(
      (value) => `\n\t${value.name}: ${value.value},`
    );
    const keys = Object.values(type.values).map(
      (value) => `\n\t\t"${value.value}": "${value.name}",`
    );
    const decode = `keys:{${keys.join("")}
}`;
    return `export const ${type.name} = {${values.join("")}\n\t${decode}};\n`;
  } else {
    return "";
  }
}

function getFunctionUtils(config: any, symbol: Symbol) {
  const symbolFN = `__symbol_fn_${symbol.name}`;
  let returns = null;
  if (symbol.returnType) {
    const symbolReturnFinalType = typeResolveAlias(symbol.returnType);
    if (!("bunType" in symbolReturnFinalType)) {
      console.warn(
        `Skipping unsupported function ${symbol.name} due to return type ${symbol.returnType}`
      );
      return "";
    }
    returns = `\treturns: ${symbolReturnFinalType.bunType}`;
  }
  const argBunTypes = [];
  for (let arg of symbol.args) {
    const finalArgType = typeResolveAlias(arg.type);
    if (!("bunType" in finalArgType)) {
      console.warn(
        `Skipping unsupported function ${symbol.name} due to arg type ${arg.type}`
      );
      return "";
    }
    argBunTypes.push(finalArgType.bunType);
  }

  const smartArgSerialization = symbol.args
    .map((arg: SymbolArg) => {
      const jsArgName = safeJS(arg.name);
      if (
        arg.type.class === "ptr" &&
        arg.type.to &&
        arg.type.to.class === "struct"
      ) {
        const structType = arg.type.to;
        structType.structName;
        const pre = `
        let ${jsArgName}_buffer = null
        if (${jsArgName} !== null && typeof ${jsArgName} === 'object'){
          ${jsArgName}_buffer = ${structType.structName}_to_C(${jsArgName} );
          ${jsArgName} = ${jsArgName}_buffer.ptr;
}`;
        const post = `
      ${jsArgName}_buffer && ${jsArgName}_buffer.free()
      `;
        return { pre, post };
      }
      return null;
    })
    .filter((x) => x !== null) as any;

  return `
let ${symbolFN} = null;
export function ${symbol.name}(${symbol.args
    .map((arg) => safeJS(arg.name))
    .join(", ")}){
  let fn = ${symbolFN};
  if (fn === null){
    ${symbolFN} = dlopen("${config.libraryPath}", {${symbol.name}: {
      args: [${argBunTypes.join(",")}],
      ${returns}
    }}).symbols.${symbol.name};
    fn = ${symbolFN};
  }
  ${smartArgSerialization.map((x: any) => x.pre).join("")}
  const ___ret =  fn(${symbol.args.map((arg) => safeJS(arg.name)).join(", ")});
  ${smartArgSerialization.map((x: any) => x.post).join("")}
  return ___ret;
}
  `;
}

function safeJS(arg: string) {
  return `${arg}_`;
}

function typeResolveAlias(type: Type): NonAliasTypes {
  while (type.class === "alias") {
    type = type.to;
  }
  return type;
}

function typeResolveBytes(type: Type): number {
  const rto = typeResolveAlias(type);
  if ("bytes" in rto) {
    return rto.bytes;
  }
  return Number.NaN;
}

function getSymbolMap(config: any, ast: any, typeMap: TypeMap): SymbolMap {
  const symbolMap = {} as SymbolMap;
  ast.ext
    .filter(
      (node: any) =>
        node.coord.includes(config.filterBy || config.headerFile) &&
        node._nodetype === "Decl" &&
        node.type._nodetype === "FuncDecl"
    )
    .forEach((node: any) => {
      const name = node.name;
      const returnType = getType(node.type, typeMap);
      const args = node.type.args.params
        .map((nodeArg: any) => {
          let n = nodeArg.type;
          let name;
          while (true) {
            if (n.declname) {
              name = n.declname;
              break;
            }
            if (n.names && n.names[0] === "void") {
              return null;
            }
            n = n.type;
          }
          return {
            name,
            type: getType(nodeArg, typeMap),
          };
        })
        .filter((x: SymbolArg | null) => x !== null) as SymbolArg[];
      symbolMap[name] = {
        name,
        args,
        returnType,
      };
    });
  return symbolMap;
}

function getType(node: any, typeMap: TypeMap): Type {
  let typeName;
  try {
    let n = node;
    while (!n.names) {
      n = n.type;
    }
    typeName = n.names[0];
  } catch (error) {
    console.error(node);
    throw error;
  }
  if (node.type._nodetype === "PtrDecl") {
    return {
      class: "ptr",
      bytes: 8,
      to: typeMap[typeName],
      bunType: "FFIType.ptr",
    };
  }
  // Some types are not found correctly, default to UInt64 in the meantime
  return typeMap[typeName] || Uint64;
}

async function getMacroDefinitions(config: any): Promise<MacroConstantMap> {
  const macroConstantMap = {} as MacroConstantMap;
  const headers = config.macroLookupHeaders || [config.headerFile];
  for (let header of headers) {
    const data = await fs.readFile(header, { encoding: "utf8" });
    const numeric_define =
      /#define\s+(?<name>\w+)\s+((?<hex>0x[0-9a-fA-F]+)|(?<integer>-?[0-9]+)|(?<decimal>-?[0-9]+\.[0-9]+)|(?<maxU32>)\(~0U\))$/;
    data.split("\n").forEach((line) => {
      const result = numeric_define.exec(line);
      if (!result) {
        return;
      }
      const name = result[1];
      let value = result.slice(2).find((x) => x !== "") as number | string;
      if (!Number.isNaN(Number(value))) {
        value = Number(value);
      } else if (line.includes("(~0U)")) {
        // TODO implement some basic expressions to process values like this
        value = 4294967295;
      }
      macroConstantMap[name] = {
        name,
        value,
      };
    });
  }
  return macroConstantMap;
}

main();
